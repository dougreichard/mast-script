exports.ids = ["main~run"];
exports.modules = {

/***/ "./src/nut-lex.js":
/*!************************!*\
  !*** ./src/nut-lex.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nconst { createToken, createTokenInstance, Lexer } = __webpack_require__(/*! chevrotain */ \"./node_modules/chevrotain/lib/src/api.js\")\r\n//const _ = require(\"lodash\")\r\nconst _ = {\r\n    isEmpty: __webpack_require__(/*! lodash.isempty */ \"./node_modules/lodash.isempty/index.js\"),\r\n    last: __webpack_require__(/*! lodash.last */ \"./node_modules/lodash.last/index.js\"),\r\n    partialRight: __webpack_require__(/*! lodash.partialright */ \"./node_modules/lodash.partialright/index.js\")\r\n}\r\n\r\nlet allLex = {};\r\nlet tokStack = [];\r\n// Help function to eliminate repetative stuff\r\n// make it easier to read\r\n// tokens are stacked LIFO\r\n// \r\nfunction tok(name, pattern, opt) {\r\n    if (!opt) { opt = {} };\r\n    opt.name = name;\r\n    opt.pattern = pattern;\r\n    let tok = createToken(opt);\r\n    allLex[name] = tok;\r\n    tokStack.unshift(tok);\r\n    return tok\r\n}\r\n\r\n/**\r\n *\r\n * Works like a / +/y regExp.\r\n *  - Note the usage of the 'y' (sticky) flag.\r\n *    This can be used to match from a specific offset in the text\r\n *    in our case from startOffset.\r\n *\r\n * The reason this has been implemented \"manually\" is because the sticky flag is not supported\r\n * on all modern node.js versions (4.0 specifically).\r\n */\r\nfunction matchWhiteSpace(text, startOffset) {\r\n    let result = \"\"\r\n    let offset = startOffset\r\n    // ignoring tabs in this example\r\n    while (text[offset] === \" \") {\r\n        offset++\r\n        result += \" \"\r\n    }\r\n   \r\n\r\n    if (result === \"\") {\r\n        return null\r\n    }\r\n\r\n    return [result]\r\n}\r\n\r\n// State required for matching the indentations\r\nlet indentStack = [0]\r\nlet lastOffsetChecked\r\n/**\r\n * This custom Token matcher uses Lexer context (\"matchedTokens\" and \"groups\" arguments)\r\n * combined with state via closure (\"indentStack\" and \"lastTextMatched\") to match indentation.\r\n *\r\n * @param {string} text - remaining text to lex, sent by the Chevrotain lexer.\r\n * @param {IToken[]} matchedTokens - Tokens lexed so far, sent by the Chevrotain Lexer.\r\n * @param {object} groups - Token groups already lexed, sent by the Chevrotain Lexer.\r\n * @param {string} type - determines if this function matches Indent or Outdent tokens.\r\n * @returns {*}\r\n */\r\nfunction matchIndentBase(text, offset, matchedTokens, groups, type) {\r\n    const noTokensMatchedYet = _.isEmpty(matchedTokens)\r\n    const newLines = groups.nl\r\n    const noNewLinesMatchedYet = _.isEmpty(newLines)\r\n    const isFirstLine = noTokensMatchedYet && noNewLinesMatchedYet\r\n    const isStartOfLine =\r\n        // only newlines matched so far\r\n        (noTokensMatchedYet && !noNewLinesMatchedYet) ||\r\n        // Both newlines and other Tokens have been matched \r\n        // AND the last matched Token is a newline\r\n        (!noTokensMatchedYet &&\r\n            !noNewLinesMatchedYet &&\r\n            (_.last(newLines).endOffset === (offset-1)))\r\n\r\n    // indentation can only be matched at the start of a line.\r\n    if (isFirstLine || isStartOfLine) {\r\n        let match\r\n        let currIndentLevel = undefined\r\n        const isZeroIndent = text.length > offset && text[offset] !== \" \"\r\n        if (isZeroIndent) {\r\n            // Matching zero spaces Outdent would not consume any chars, thus it would cause an infinite loop.\r\n            // This check prevents matching a sequence of zero spaces outdents.\r\n            if (lastOffsetChecked !== offset) {\r\n                currIndentLevel = 0\r\n                match = [\"\"]\r\n                lastOffsetChecked = offset\r\n            }\r\n        } else {\r\n            // possible non-empty indentation\r\n            match = matchWhiteSpace(text, offset)\r\n            if (match !== null) {\r\n                currIndentLevel = match[0].length\r\n                lastOffsetChecked = offset\r\n            }\r\n        }\r\n\r\n        if (currIndentLevel !== undefined) {\r\n            const lastIndentLevel = _.last(indentStack)\r\n            if (currIndentLevel > lastIndentLevel && type === \"indent\") {\r\n                indentStack.push(currIndentLevel)\r\n                return match\r\n            } else if (\r\n                currIndentLevel < lastIndentLevel &&\r\n                type === \"outdent\"\r\n            ) {\r\n                //if we need more than one outdent token, add all but the last one\r\n                if (indentStack.length > 2) {\r\n                    const image = \"\"\r\n                    const offset = _.last(matchedTokens).endOffset + 1\r\n                    const line = _.last(matchedTokens).endLine\r\n                    const column = _.last(matchedTokens).endColumn + 1\r\n                    while (\r\n                        indentStack.length > 2 &&\r\n                        //stop before the last Outdent\r\n                        indentStack[indentStack.length - 2] > currIndentLevel\r\n                    ) {\r\n                        indentStack.pop()\r\n                        matchedTokens.push(\r\n                            createTokenInstance(\r\n                                allLex.Outdent,\r\n                                \"\",\r\n                                NaN,\r\n                                NaN,\r\n                                NaN,\r\n                                NaN,\r\n                                NaN,\r\n                                NaN\r\n                            )\r\n                        )\r\n                    }\r\n                }\r\n                indentStack.pop()\r\n                return match\r\n            } else {\r\n                // same indent, this should be lexed as simple whitespace and ignored\r\n                return null\r\n            }\r\n        } else {\r\n            // indentation cannot be matched without at least one space character.\r\n            return null\r\n        }\r\n    } else {\r\n        // indentation cannot be matched under other circumstances\r\n        return null\r\n    }\r\n}\r\n\r\n\r\n\r\n// customize matchIndentBase to create separate functions of Indent and Outdent.\r\nconst matchIndent = _.partialRight(matchIndentBase, \"indent\")\r\nconst matchOutdent = _.partialRight(matchIndentBase, \"outdent\")\r\n\r\n// newlines are not skipped, by setting their group to \"nl\" they are saved in the lexer result\r\n// and thus we can check before creating an indentation token that the last token matched was a newline.\r\n\r\n//tok(\"BlankLines\", /\\s*$/, { group: Lexer.SKIPPED })\r\n\r\n\r\ntok(\"Sub\", /-/);\r\ntok(\"IntegerLiteral\", /-?\\d+/);\r\ntok(\"NumberLiteral\", /-?(0|[1-9]\\d*)(\\.\\d+)+([eE][+-]?\\d+)?/);\r\ntok(\"MinuteLiteral\", /(\\d+)(m)/);\r\ntok(\"SecondLiteral\", /(\\d+)(s)/);\r\ntok(\"MillisecondLiteral\", /(\\d+)(ms)/);\r\n\r\ntok(\"SingleLineComment\", /[/]+.*/, { group: Lexer.SKIPPED })\r\ntok(\"BlockComment\", /\\/[*]([^*]|([*][^/]))*[*]\\//, { group: Lexer.SKIPPED })\r\n\r\n//tok(\"DoubleStringLiteral\", /\"(:?[^\\\\\"]|\\\\(:?[bfnrtv\"\\\\/]|u[0-9a-fA-F]{4}))*\"/);\r\n//tok(\"TickStringLiteral\", /`(:?[^\\\\`]|\\\\(:?[bfnrtv`\\\\/]|u[0-9a-fA-F]{4}))*`/);\r\n//tok(\"SingleStringLiteral\", /'(:?[^\\\\']|\\\\(:?[bfnrtv'\\\\/]|u[0-9a-fA-F]{4}))*'/)\r\n\r\ntok(\"StringLiteral\", /\"(:?[^\\\\\"]|\\\\(:?[bfnrtv\"\\\\/]|u[0-9a-fA-F]{4}))*\"|'(:?[^\\\\']|\\\\(:?[bfnrtv'\\\\/]|u[0-9a-fA-F]{4}))*'|`(:?[^`]|\\\\(:?[bfnrtv'\\\\/]|u[0-9a-fA-F]{4}))*`/);\r\nconst Identifier = tok(\"Identifier\", /[a-zA-Z_]+\\w*/);\r\ntok(\"LineContinue\", /_\\s+/, {line_breaks: false, group: Lexer.SKIPPED, longer_alt: Identifier  })\r\n//\r\n\r\n//tok(\"Minutes\", /minutes/, { longer_alt: Identifier });\r\n//tok(\"Seconds\", /s/, { longer_alt: Identifier });\r\n//tok(\"MilliSeconds\", /ms/, { longer_alt: Identifier });\r\ntok(\"InOp\", /in/, { longer_alt: Identifier });\r\ntok(\"RangeOp\", /range/, { longer_alt: Identifier });\r\ntok(\"HasOp\", /has/, { longer_alt: Identifier });\r\ntok(\"SubOp\", /sub/, { longer_alt: Identifier });\r\ntok(\"TogetherOp\", /together/, { longer_alt: Identifier });\r\n\r\ntok(\"DoCmd\", /do/, { longer_alt: Identifier });\r\ntok(\"PassCmd\", /pass/, { longer_alt: Identifier });\r\ntok(\"AsCmd\", /as/, { longer_alt: Identifier });\r\ntok(\"WithCmd\", /with/, { longer_alt: Identifier });\r\ntok(\"TellCmd\", /tell/, { longer_alt: Identifier });\r\ntok(\"CueCmd\", /cue/, { longer_alt: Identifier });\r\ntok(\"SceneCmd\", /scene/, { longer_alt: Identifier });\r\ntok(\"SetCmd\", /set/, { longer_alt: Identifier });\r\ntok(\"DelayCmd\", /delay/, { longer_alt: Identifier });\r\ntok(\"ForCmd\", /for/, { longer_alt: Identifier });\r\n\r\n\r\n\r\ntok(\"True\", /true/, { longer_alt: Identifier });\r\ntok(\"False\", /false/, { longer_alt: Identifier });\r\ntok(\"Null\", /null/, { longer_alt: Identifier });\r\n//\r\ntok(\"Comma\", /,/);\r\ntok(\"Colon\", /:/);\r\ntok(\"SemiColon\", /;/);\r\ntok(\"LParen\", /\\(/);\r\ntok(\"RParen\", /\\)/);\r\ntok(\"LBracket\", /\\[/);\r\ntok(\"RBracket\", /\\]/);\r\ntok(\"LBrace\", /\\{/);\r\ntok(\"RBrace\", /\\}/);\r\n//\r\ntok(\"CastId\", /@\\w+/);\r\ntok(\"MediaId\", /!\\w+/);\r\ntok(\"SceneId\", /\\$\\w+/);\r\ntok(\"RoleId\", /#\\w+/);\r\ntok(\"InteractionId\", /\\?\\w+/);\r\ntok(\"ObjectiveId\", /\\*\\w+/);\r\ntok(\"DataId\", /\\.\\w*/);\r\n// Sections\r\ntok(\"ScriptSec\", /script/, { longer_alt: Identifier });\r\ntok(\"MediaSec\", /media/, { longer_alt: Identifier });\r\ntok(\"RoleSec\", /roles/, { longer_alt: Identifier });\r\ntok(\"CastSec\", /cast/, { longer_alt: Identifier });\r\ntok(\"SceneSec\", /scenes/, { longer_alt: Identifier });\r\ntok(\"StorySec\", /story/, { longer_alt: Identifier });\r\ntok(\"ImportSec\", /imports/, { longer_alt: Identifier });\r\n// \r\ntok(\"SearchCmd\", /search/, { longer_alt: Identifier });\r\n// \r\ntok(\"StartupBlock\", /startup/, { longer_alt: Identifier });\r\ntok(\"EnterBlock\", /enter/, { longer_alt: Identifier });\r\ntok(\"LeaveBlock\", /leave/, { longer_alt: Identifier });\r\n//\r\ntok(\"ObjectiveBlock\", /objective/, { longer_alt: Identifier });\r\ntok(\"ObjectiveSec\", /objectives/, { longer_alt: Identifier });\r\n\r\n// tok(\"WhenSec\", /when/, { longer_alt: Identifier });\r\n// Objective Commands\r\ntok(\"CompleteCmd\", /complete/, { longer_alt: Identifier });\r\ntok(\"FailCmd\", /fail/, { longer_alt: Identifier });\r\ntok(\"HideCmd\", /hide/, { longer_alt: Identifier });\r\ntok(\"ShowCmd\", /show/, { longer_alt: Identifier });\r\ntok(\"AskCmd\", /ask/, { longer_alt: Identifier });\r\ntok(\"ClickCmd\", /click/, { longer_alt: Identifier });\r\n// Conditions\r\ntok(\"NearCond\", /near/, { longer_alt: Identifier });\r\ntok(\"HasRoleCond\", /has-role/, { longer_alt: Identifier });\r\ntok(\"AndCond\", /and/, { longer_alt: Identifier });\r\ntok(\"OrCond\", /or/, { longer_alt: Identifier });\r\ntok(\"DurationCond\", /duration/, { longer_alt: Identifier });\r\n// \r\ntok(\"InteractionBlock\", /interaction/, { longer_alt: Identifier });\r\ntok(\"InteractionSec\", /interactions/, { longer_alt: Identifier });\r\n\r\ntok(\"FormBlock\", /form/, { longer_alt: Identifier });\r\ntok(\"ChoiceBlock\", /choice/, { longer_alt: Identifier });\r\ntok(\"KeysBlock\", /keys/, { longer_alt: Identifier });\r\n// form elements\r\ntok(\"InputElement\", /input/, { longer_alt: Identifier });\r\ntok(\"LabelElement\", /label/, { longer_alt: Identifier });\r\ntok(\"SelectElement\", /select/, { longer_alt: Identifier });\r\ntok(\"SubmitElement\", /submit/, { longer_alt: Identifier });\r\n//\r\ntok(\"If\", /if/, { longer_alt: Identifier });\r\ntok(\"Else\", /else/, { longer_alt: Identifier });\r\ntok(\"Always\", /always/, { longer_alt: Identifier });\r\n\r\n// operators\r\ntok(\"IsOp\", /is/, { longer_alt: Identifier });\r\ntok(\"GT_Op\", />/);\r\ntok(\"LT_Op\", /</);\r\n// set operators\r\ntok(\"Assign\", /=/);\r\ntok(\"Equals\", /==/);\r\ntok(\"NotEquals\", /!=/);\r\ntok(\"GE_Op\", />=/);\r\ntok(\"LE_Op\", /<=/);\r\n\r\ntok(\"AssignAdd\", /\\+=/);\r\ntok(\"AssignSub\", /-=/);\r\ntok(\"AssignMul\", /\\*=/);\r\ntok(\"AssignPercentAdd\", /\\%\\+/);\r\ntok(\"AssignPercentSub\", /\\%-/);\r\n\r\n\r\n\r\n/////////////////////////////////////\r\n// These rule must be first\r\ntok(\"WhiteSpace\", /[ \\t]+/, { group: Lexer.SKIPPED })\r\n\r\ntok(\"Indent\", matchIndent, { line_breaks: false })\r\ntok(\"Outdent\", matchOutdent, { line_breaks: false })\r\n// custom token patterns should explicitly specify the line_breaks option\r\n\r\ntok(\"Newline\", /\\n|\\r\\n|\\r/, { group: \"nl\" });\r\n\r\n\r\nconst spsLexer = new Lexer(tokStack);\r\n\r\nmodule.exports = {\r\n    tokens: allLex,\r\n\r\n    tokenize: function (text) {\r\n        // have to reset the indent stack between processing of different text inputs\r\n        indentStack = [0]\r\n        lastOffsetChecked = undefined\r\n\r\n        const lexResult = spsLexer.tokenize(text)\r\n\r\n        //add remaining Outdents\r\n        while (indentStack.length > 1) {\r\n            lexResult.tokens.push(\r\n                createTokenInstance(allLex.Outdent, \"\", NaN, NaN, NaN, NaN, NaN, NaN)\r\n            )\r\n            indentStack.pop()\r\n        }\r\n         return lexResult\r\n    }\r\n}\n\n//# sourceURL=webpack:///./src/nut-lex.js?");

/***/ }),

/***/ "./src/nut-parser.js":
/*!***************************!*\
  !*** ./src/nut-parser.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(__dirname) {const NutLexer = __webpack_require__(/*! ./nut-lex */ \"./src/nut-lex.js\")\r\nconst { Parser } = __webpack_require__(/*! chevrotain */ \"./node_modules/chevrotain/lib/src/api.js\")\r\nconst fs = __webpack_require__(/*! fs */ \"fs\")\r\nconst path = __webpack_require__(/*! path */ \"path\")\r\n\r\nconst expressionsRules = __webpack_require__(/*! ./rules/expressions */ \"./src/rules/expressions.js\");\r\nconst mediaRules = __webpack_require__(/*! ./rules/media */ \"./src/rules/media.js\");\r\nconst roleRules = __webpack_require__(/*! ./rules/role */ \"./src/rules/role.js\");\r\nconst castRules = __webpack_require__(/*! ./rules/cast */ \"./src/rules/cast.js\");\r\nconst scriptRules = __webpack_require__(/*! ./rules/script */ \"./src/rules/script.js\");\r\nconst sceneRules = __webpack_require__(/*! ./rules/scene */ \"./src/rules/scene.js\");\r\nconst valueRules = __webpack_require__(/*! ./rules/value */ \"./src/rules/value.js\");\r\nconst cmdRules = __webpack_require__(/*! ./rules/commands */ \"./src/rules/commands.js\");\r\nconst conRules = __webpack_require__(/*! ./rules/conditions */ \"./src/rules/conditions.js\");\r\nconst stateRules = __webpack_require__(/*! ./rules/states */ \"./src/rules/states.js\");\r\nconst objectiveRules = __webpack_require__(/*! ./rules/objectives */ \"./src/rules/objectives.js\");\r\nconst interactionRules = __webpack_require__(/*! ./rules/interactions */ \"./src/rules/interactions.js\");\r\nconst importRules = __webpack_require__(/*! ./rules/import */ \"./src/rules/import.js\");\r\n\r\n\r\n\r\nclass NutParser extends Parser {\r\n    constructor(listener) {\r\n        super(Object.values(NutLexer.tokens), { outputCst: false })\r\n        this.listener = listener\r\n        expressionsRules(this);\r\n        mediaRules(this);\r\n        roleRules(this);\r\n        castRules(this);\r\n        cmdRules(this);\r\n        conRules(this);\r\n        importRules(this);\r\n        stateRules(this);\r\n        objectiveRules(this);\r\n        interactionRules(this);\r\n        sceneRules(this);\r\n        // maybe this should be yaml\r\n        valueRules(this);\r\n        scriptRules(this);\r\n\r\n        this._anonymousId = 0;\r\n\r\n        this.performSelfAnalysis()\r\n    }\r\n\r\n    anonymousID(prefix) {\r\n\r\n        return `${prefix}${this._anonymousId++}`\r\n    }\r\n\r\n    trimString(str) {\r\n        return str.slice(1,-1)\r\n    }\r\n\r\n    parseFile(fileName) {\r\n        let baseDir = NutParser.defaultPaths[NutParser.defaultPaths.length-1]\r\n        NutParser.defaultPaths.push(path.dirname(fileName))\r\n        try {\r\n            fileName = path.resolve(baseDir, fileName)\r\n            let input = fs.readFileSync(fileName, 'utf8');\r\n            let out = this.parseFragment(input, 'script');\r\n            //out.parseErrors.length\r\n            return out;\r\n        }\r\n        catch(e) {\r\n            console.log(e.message)\r\n            throw e\r\n        }\r\n        finally {\r\n            NutParser.defaultPaths.pop();\r\n        }\r\n        return {\r\n            value:0, // this is a pure grammar, the value will always be <undefined>\r\n            lexErrors: [],\r\n            parseErrors: []\r\n        }\r\n    }\r\n    parseFragment(input, fragment) {\r\n        const lexResult = NutLexer.tokenize(input)\r\n        if (lexResult.errors.length > 0) {\r\n            return {\r\n                value: undefined, // this is a pure grammar, the value will always be <undefined>\r\n                lexErrors: lexResult.errors,\r\n                parseErrors: undefined\r\n            }    \r\n        }\r\n        // setting a new input will RESET the parser instance's state.\r\n        this.input = lexResult.tokens\r\n        // any top level rule may be used as an entry point\r\n        const value = this[fragment]()\r\n        return {\r\n            value: value, // this is a pure grammar, the value will always be <undefined>\r\n            lexErrors: lexResult.errors,\r\n            parseErrors: this.errors\r\n        }\r\n    }\r\n    \r\n\r\n    addMedia(media) {if (this.listener) this.listener.addMedia(media);}\r\n    addCast(cast) {if (this.listener) this.listener.addCast(cast);}\r\n    addRole(role) {if (this.listener) this.listener.addRole(role);}\r\n    addObjective(obj) {if (this.listener) this.listener.addObjective(obj);}\r\n    pushInteraction(interaction) {if (this.listener) this.listener.pushInteraction(interaction);}\r\n    popInteraction(id) {if (this.listener) this.listener.popInteraction();}\r\n    addScript(script) {if (this.listener) this.listener.addScript(script);}\r\n    pushScript() {if (this.listener) this.listener.pushScript();}\r\n    popScript() {if (this.listener) this.listener.popScript();}\r\n    pushStory(story) {if (this.listener) this.listener.pushStory(story);}\r\n    popStory(story) {if (this.listener) this.listener.popStory(story);}\r\n    pushScene(scene) {if (this.listener) this.listener.pushScene(scene);}\r\n    popScene(scene) {if (this.listener) this.listener.popScene(scene);}\r\n    pushShot(shot) {if (this.listener) this.listener.pushShot(shot);}\r\n    popShot(shot) {if (this.listener) this.listener.popScene(shot);}\r\n    pushImport() {if (this.listener) this.listener.pushImport();}\r\n    popImport() {if (this.listener) this.listener.popImport();}\r\n    importScript(id) {if (this.listener) this.listener.importScript(id);}\r\n}\r\nNutParser.defaultPaths = [__dirname]\r\nmodule.exports = NutParser\n/* WEBPACK VAR INJECTION */}.call(this, \"/\"))\n\n//# sourceURL=webpack:///./src/nut-parser.js?");

/***/ }),

/***/ "./src/nut-types.js":
/*!**************************!*\
  !*** ./src/nut-types.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const SymbolTypes = {\r\n    Media: 1,\r\n    Cast: 2,\r\n    Role: 3,\r\n    Story: 4,\r\n    Scene: 5,\r\n    Shot: 6,\r\n    Objective: 7,\r\n    Interaction: 8,\r\n    Annotation: 9\r\n\r\n}\r\n\r\nlet cmdId = 1\r\nconst CommandTypes = {\r\n    Tell: cmdId++,  \r\n    Show: cmdId++,\r\n    Hide: cmdId++,\r\n    MulAssign: cmdId++,\r\n    PresentAssign: cmdId++,\r\n    Delay: cmdId++,\r\n    Do: cmdId++,\r\n    For: cmdId++,\r\n    Set: cmdId++,\r\n    Scene: cmdId++,\r\n    As: cmdId++,\r\n    Cue: cmdId++\r\n}\r\n\r\nconst TellTypes = {\r\n    RoleCast: 1,  // Tell specific cast or role\r\n    Scene: 2,   // tell everyone currently in a scene\r\n    Story: 3  // tell everyone\r\n}\r\n\r\n\r\nconst UnwindTypes = {\r\n    Shot: 1,  // Tell specific cast or role\r\n    Scene: 2,   // tell everyone currently in a scene\r\n}\r\n\r\nconst IteratorTypes = {\r\n    Set: 1,\r\n    Range: 2\r\n}\r\n\r\n\r\nconst SetOperations = {\r\n    Assign: 1,  \r\n    AssignAdd: 2,\r\n    AssignSub: 3,\r\n    AssignMul: 4,\r\n    AssignPercentAdd: 5,\r\n    AssignPercentSub: 6\r\n\r\n}\r\n\r\nlet interId = 1\r\nconst InteractionTypes = {\r\n    Choice: interId++,  \r\n    Form: interId++,\r\n}\r\n\r\nmodule.exports = {\r\n    SymbolTypes,\r\n    TellTypes,\r\n    CommandTypes,\r\n    IteratorTypes,\r\n    SetOperations,\r\n    InteractionTypes,\r\n    UnwindTypes\r\n}\n\n//# sourceURL=webpack:///./src/nut-types.js?");

/***/ }),

/***/ "./src/rules/cast.js":
/*!***************************!*\
  !*** ./src/rules/cast.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const spsLexer = __webpack_require__(/*! ../nut-lex */ \"./src/nut-lex.js\")\r\n// const { Parser } = require(\"chevrotain\")\r\nconst toks = spsLexer.tokens\r\n\r\nmodule.exports = ($) => {\r\n    // cast-definition-block\r\n    //  : CAST_STATEMENT COLON INDENT cast-definition* DEDENT\r\n    // ;\r\n    $.RULE('cast', () => {\r\n        $.CONSUME(toks.CastSec);\r\n        $.CONSUME(toks.Colon)\r\n        $.CONSUME(toks.Indent)\r\n        $.MANY(() => {\r\n            let annotations= $.SUBRULE($.annotationList)\r\n            let meta = $.SUBRULE($.castDef)\r\n            annotations.meta = meta\r\n            annotations.id = meta.id;\r\n            $.addCast(annotations)\r\n        })\r\n        $.CONSUME(toks.Outdent)\r\n    })\r\n    // cast-definition\r\n    // :  CAST_ID (alias-string)? (role-list)? string? \r\n    // |  ID (alias-string)? (role-list)? string? \r\n    // ;\r\n    $.RULE(\"castDef\", () => {\r\n        let id = $.OR([\r\n            {ALT: ()=> $.CONSUME(toks.CastId).image},\r\n            {ALT: ()=> '@'+$.CONSUME(toks.Identifier).image}\r\n        ]);\r\n        let alias = $.OPTION(() =>  $.SUBRULE($.aliasString))\r\n        let roles = $.OPTION2(() => $.SUBRULE($.roleIdList))\r\n        let desc = $.OPTION3(() =>  $.CONSUME2(toks.StringLiteral).image)\r\n        return {id, alias, roles, desc}\r\n        \r\n    })\r\n   \r\n}\r\n\n\n//# sourceURL=webpack:///./src/rules/cast.js?");

/***/ }),

/***/ "./src/rules/commands.js":
/*!*******************************!*\
  !*** ./src/rules/commands.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const spsLexer = __webpack_require__(/*! ../nut-lex */ \"./src/nut-lex.js\")\r\nconst { IteratorTypes, SetOperations, TellTypes, CommandTypes } = __webpack_require__(/*! ../nut-types */ \"./src/nut-types.js\")\r\n// const { Parser } = require(\"chevrotain\")\r\nconst toks = spsLexer.tokens\r\n\r\nmodule.exports = ($) => {\r\n    $.RULE('annotationId', () => {\r\n        $.CONSUME(toks.LT_Op)\r\n        let id = $.CONSUME(toks.Identifier).image\r\n        $.CONSUME(toks.GT_Op)\r\n        return id;\r\n    })\r\n    $.RULE('annotation', () => {\r\n        $.CONSUME(toks.LT_Op)\r\n        let id = $.CONSUME(toks.Identifier).image\r\n        let value = $.OPTION(()=> $.SUBRULE($.value))\r\n        // If there is no value we need it to be true to know the \r\n        // annotations exists\r\n        if (value === undefined) {\r\n            value = true\r\n        }\r\n        $.CONSUME(toks.GT_Op)\r\n        return {  key: id,  value } \r\n    })\r\n    $.RULE('annotationList', ()=> {\r\n        let annotations = {}\r\n        $.MANY(() => {\r\n            let {key, value} = $.SUBRULE1($.annotation)\r\n            annotations[key] = value\r\n        })\r\n        return annotations\r\n    })\r\n\r\n    $.RULE('doCmd', () => {\r\n        $.CONSUME(toks.DoCmd)\r\n        let together = $.OPTION(() => $.CONSUME(toks.TogetherOp).image ? true : false)\r\n        let shots = $.SUBRULE($.shotList)\r\n        return { type: CommandTypes.Do, options: { together, shots } }\r\n\r\n    })\r\n    $.RULE(\"shotList\", () => {\r\n        let shotList = []\r\n        $.OR([\r\n            { ALT: () => shotList.push($.CONSUME(toks.Identifier).image) },\r\n            {\r\n                ALT: () => {\r\n                    $.CONSUME(toks.LBracket);\r\n                    $.MANY(() => {\r\n                        shotList.push($.CONSUME1(toks.Identifier).image)\r\n                    })\r\n                    $.CONSUME(toks.RBracket);\r\n                }\r\n            }\r\n        ])\r\n        return shotList\r\n    })\r\n\r\n    // tell-command\r\n    // :  TELL_STATEMENT role-cast-list string\r\n    // ;\r\n    $.RULE('tellCmd', () => {\r\n        \r\n        let desc;\r\n        $.OR([{\r\n            ALT: () => {\r\n                $.CONSUME(toks.TellCmd)\r\n                $.OPTION1(() => $.SUBRULE($.identifierTellList))\r\n                desc = $.trimString($.CONSUME(toks.StringLiteral).image)\r\n            }\r\n        }, {\r\n            ALT: () => {\r\n                desc = $.trimString($.CONSUME1(toks.StringLiteral).image)\r\n            }\r\n        }\r\n        ])\r\n        $.OPTION(()=> $.SUBRULE($.annotationList))\r\n        return { type: CommandTypes.Tell, options: { desc } }\r\n\r\n    })\r\n\r\n    $.RULE('cueCmd', () => {\r\n        $.OPTION(() => $.CONSUME(toks.CueCmd))\r\n        let content = $.SUBRULE($.aliasString)\r\n        return {type: CommandTypes.Cue, options: { content } }\r\n\r\n    })\r\n\r\n    $.RULE('asCmd', () => {\r\n        $.OPTION(() => $.CONSUME(toks.AsCmd))\r\n        let id =$.CONSUME(toks.CastId)\r\n        let content = $.SUBRULE($.aliasCmdList)\r\n        return {type: CommandTypes.As, options: { id, content } }\r\n\r\n    })\r\n\r\n    $.RULE(\"aliasCmdList\", () => {\r\n        let cmds = []\r\n        $.CONSUME(toks.Colon);\r\n        $.CONSUME(toks.Indent)\r\n        \r\n        $.AT_LEAST_ONE(()=> { \r\n            let annotations= $.SUBRULE($.annotationList)\r\n            let cmd = $.SUBRULE($.aliasCmd)\r\n            \r\n            if (cmd) {\r\n                cmd.annotations = annotations\r\n                cmds.push(cmd)\r\n            }\r\n        })\r\n        $.CONSUME(toks.Outdent)\r\n        return cmds\r\n    })\r\n\r\n    $.RULE(\"aliasCmd\", () => {\r\n        return $.OR([\r\n          //  { ALT: () => $.SUBRULE($.asCmd) },\r\n            { ALT: () => $.SUBRULE($.doCmd) },\r\n            { ALT: () => $.SUBRULE($.tellCmd) },\r\n            { ALT: () => $.SUBRULE($.cueCmd) },\r\n            { ALT: () => $.SUBRULE($.sceneCmd) },\r\n            { ALT: () => $.SUBRULE($.setCmd) },\r\n            { ALT: () => $.SUBRULE($.delayCmd) },\r\n            { ALT: () => $.SUBRULE($.completeCmd) },\r\n            { ALT: () => $.SUBRULE($.showCmd) },\r\n            { ALT: () => $.SUBRULE($.hideCmd) },\r\n            { ALT: () => $.SUBRULE($.failCmd) },\r\n            // {ALT: ()=> $.SUBRULE($.askCmd)}\r\n        ])\r\n    })\r\n\r\n\r\n    $.RULE(\"identifierTellList\", () => {\r\n        $.OR([\r\n            { ALT: () => $.SUBRULE($.identifierTell) },\r\n            {\r\n                ALT: () => {\r\n                    $.CONSUME(toks.LBracket);\r\n                    $.MANY(() => {\r\n                        $.SUBRULE1($.identifierTell)\r\n                    })\r\n                    $.CONSUME(toks.RBracket);\r\n                }\r\n            }\r\n        ])\r\n    })\r\n    $.RULE(\"identifierTell\", () => {\r\n        $.OR([\r\n            { ALT: () => $.CONSUME(toks.StorySec) },\r\n            { ALT: () => $.CONSUME(toks.SceneId) },\r\n            { ALT: () => $.SUBRULE($.roleCastId) },\r\n        ])\r\n    })\r\n\r\n\r\n    $.RULE('sceneCmd', () => {\r\n        $.CONSUME(toks.SceneCmd)\r\n        let id = $.OR([\r\n            { ALT: () => $.CONSUME(toks.SceneId).image },\r\n            { ALT: () => $.CONSUME(toks.StorySec).image }\r\n        ]);\r\n        return {type: CommandTypes.Scene, options: { id} }\r\n    })\r\n    // show-command\r\n    // : SHOW_STATEMENT OBJECTIVE_ID boolean-value\r\n    // | SHOW_STATEMENT INTERACTION_ID boolean-value\r\n    // ;\r\n    $.RULE('showCmd', () => {\r\n        $.CONSUME(toks.ShowCmd)\r\n        $.OR([\r\n            { ALT: () => $.CONSUME(toks.ObjectiveId) },\r\n            { ALT: () => $.CONSUME(toks.InteractionId) }\r\n        ])\r\n    })\r\n    $.RULE('hideCmd', () => {\r\n        $.CONSUME(toks.HideCmd)\r\n        $.OR([\r\n            { ALT: () => $.CONSUME(toks.ObjectiveId) },\r\n            { ALT: () => $.CONSUME(toks.InteractionId) }\r\n        ])\r\n    })\r\n    // ask-command\r\n    // : ASK_STATEMENT INTERACTION_ID role-cast-list\r\n    // ;\r\n    $.RULE('askCmd', () => {\r\n        $.CONSUME(toks.AskCmd)\r\n        $.CONSUME(toks.InteractionId)\r\n        $.OPTION(() => {\r\n            $.SUBRULE($.roleCastIdList);\r\n        })\r\n    })\r\n    $.RULE('completeCmd', () => {\r\n        $.CONSUME(toks.CompleteCmd)\r\n        $.SUBRULE($.ObjectiveIdList)\r\n        $.SUBRULE1($.ifElseValidCmd)\r\n    })\r\n    $.RULE('failCmd', () => {\r\n        $.CONSUME(toks.FailCmd)\r\n    })\r\n\r\n\r\n\r\n    $.RULE('setCmd', () => {\r\n        $.CONSUME(toks.SetCmd)\r\n        let lhs = $.SUBRULE($.setLHS)\r\n        let op = $.OR([\r\n            { ALT: () => $.CONSUME(toks.Colon) ? SetOperations.Assign : undefined },\r\n            { ALT: () => $.CONSUME(toks.Assign) ? SetOperations.Assign : undefined },\r\n            { ALT: () => $.CONSUME(toks.AssignPercentAdd) ? SetOperations.AssignPercentAdd : undefined },\r\n            { ALT: () => $.CONSUME(toks.AssignPercentSub) ? SetOperations.AssignPercentSub : undefined },\r\n            { ALT: () => $.CONSUME(toks.AssignAdd) ? SetOperations.AssignAdd : undefined },\r\n            { ALT: () => $.CONSUME(toks.AssignSub) ? SetOperations.AssignSub : undefined },\r\n            { ALT: () => $.CONSUME(toks.AssignMul) ? SetOperations.AssignMul : undefined }\r\n        ])\r\n        let exp\r\n        let value\r\n        $.OR1([\r\n            { ALT: () => value = $.SUBRULE($.value) },\r\n            { ALT: () => exp = $.SUBRULE1($.identifierExpression) },\r\n        ])\r\n        return { type: CommandTypes.Set, options: { lhs, op, exp, value } }\r\n    })\r\n    // delay-command\r\n    // : DELAY_STATEMENT time-unit COLON when-command-block\r\n    // ;\r\n    $.RULE('delayCmd', () => {\r\n        $.OPTION(()=>$.CONSUME(toks.DelayCmd))\r\n        let ms = $.SUBRULE($.timeUnits);\r\n        return { type: CommandTypes.Delay, options: { ms } }\r\n    })\r\n    // \r\n    $.RULE('forCmd', () => {\r\n        $.CONSUME(toks.ForCmd)\r\n        let options = $.OR([\r\n            {ALT: ()=> $.SUBRULE($.forRange)},\r\n            {ALT: ()=> $.SUBRULE($.forArray)},\r\n            {ALT: ()=> $.SUBRULE($.forCast)},\r\n            {ALT: ()=> $.SUBRULE($.forRoles)},\r\n            {ALT: ()=> $.SUBRULE($.forCastFromRoles)},\r\n            {ALT: ()=> $.SUBRULE($.forScenes)},\r\n            {ALT: ()=> $.SUBRULE($.forShots)},\r\n        ])\r\n        options.content = $.SUBRULE($.IfElseCmdBlock)\r\n        \r\n        return { type: CommandTypes.For, options }      \r\n    })\r\n\r\n    $.RULE(\"forRange\", () => {\r\n        let id = $.CONSUME(toks.Identifier).image\r\n        $.CONSUME(toks.InOp);\r\n        $.CONSUME(toks.RangeOp)\r\n        $.CONSUME(toks.LParen)\r\n        let start = $.CONSUME(toks.IntegerLiteral).image\r\n        let end\r\n        let step = 1\r\n        $.OPTION(() => {\r\n            $.CONSUME(toks.Comma);\r\n            end = $.CONSUME1(toks.IntegerLiteral).image\r\n        })\r\n        $.OPTION1(() => {\r\n            $.CONSUME1(toks.Comma);\r\n            step = $.CONSUME2(toks.IntegerLiteral).image\r\n        })\r\n\r\n        $.CONSUME(toks.RParen)\r\n        if (!end) { end = parseInt(start); start = 0 }\r\n        else { start = parseInt(start); end = parseInt(end); step = parseInt(step) }\r\n        return { type: IteratorTypes.Range, id, start, end, step }\r\n    });\r\n\r\n    // $.RULE(\"rangeArray\", () => {\r\n    //     let array = []\r\n    //     $.CONSUME(toks.LBracket)\r\n    //     $.OR([\r\n    //         {ALT: ()=> $.SUBRULE($.rangeSceneIDArray)},\r\n    //         {ALT: ()=> $.SUBRULE($.rangeCastIDArray)},\r\n    //         {ALT: ()=> $.SUBRULE($.rangeRoleIDArray)},\r\n    //         {ALT: ()=> $.SUBRULE($.rangeShotIDArray)},\r\n    //         {ALT: ()=>  $.SUBRULE($.rangeValueArray)}\r\n    //     ])\r\n    //     $.CONSUME(toks.RBracket)\r\n    //     return { type: IteratorTypes.Set, set: array }\r\n    // })\r\n\r\n    $.RULE(\"forArray\", () => {\r\n        let id = $.CONSUME(toks.Identifier).image\r\n        let elements = []\r\n        $.CONSUME(toks.InOp);\r\n        $.CONSUME(toks.LBracket)\r\n        \r\n        $.AT_LEAST_ONE_SEP({\r\n            SEP: toks.Comma,\r\n            DEF: () => $.SUBRULE2($.value)\r\n        })\r\n        $.CONSUME(toks.RBracket)\r\n        return { type: IteratorTypes.Array, id, elements }\r\n    })\r\n\r\n    $.RULE(\"forScenes\", () => {\r\n        let id = $.CONSUME(toks.SceneId).image\r\n        let elements = []\r\n        $.CONSUME(toks.InOp);\r\n        $.CONSUME(toks.LBracket)\r\n        $.AT_LEAST_ONE( () => $.CONSUME2(toks.SceneId).image)\r\n        $.CONSUME(toks.RBracket)\r\n        return { type: IteratorTypes.Set, id, elements }\r\n    })\r\n\r\n    $.RULE(\"forCast\", () => {\r\n        let id = $.CONSUME(toks.CastId).image\r\n        let elements = []\r\n        $.CONSUME(toks.InOp);\r\n        $.CONSUME(toks.LBracket)\r\n        $.AT_LEAST_ONE( () => $.CONSUME2(toks.CastId).image)\r\n        $.CONSUME(toks.RBracket)\r\n        return { type: IteratorTypes.Set, id, elements }\r\n    })\r\n\r\n    $.RULE(\"forRoles\", () => {\r\n        let id = $.CONSUME(toks.RoleId).image\r\n        let elements = []\r\n        $.CONSUME(toks.InOp);\r\n        $.CONSUME(toks.LBracket)\r\n        $.AT_LEAST_ONE( () => $.CONSUME2(toks.RoleId).image)\r\n        $.CONSUME(toks.RBracket)\r\n        return { type: IteratorTypes.Set, id, elements }\r\n    })\r\n\r\n    $.RULE(\"forCastFromRoles\", () => {\r\n        let id = $.CONSUME(toks.CastId).image\r\n        let elements = []\r\n        $.CONSUME(toks.InOp);\r\n        $.CONSUME(toks.LBracket)\r\n        $.AT_LEAST_ONE( () => $.CONSUME2(toks.RoleId).image)\r\n        $.CONSUME(toks.RBracket)\r\n        return { type: IteratorTypes.Set, id, elements }\r\n    })\r\n\r\n    $.RULE(\"forShots\", () => {\r\n        let id = $.CONSUME(toks.Identifier).image\r\n        let elements = []\r\n        $.CONSUME(toks.InOp);\r\n        $.CONSUME(toks.LBracket)\r\n        $.AT_LEAST_ONE( () => $.CONSUME2(toks.Identifier).image)\r\n        $.CONSUME(toks.RBracket)\r\n        return { type: IteratorTypes.Set, id, elements }\r\n    })\r\n\r\n}\r\n\n\n//# sourceURL=webpack:///./src/rules/commands.js?");

/***/ }),

/***/ "./src/rules/conditions.js":
/*!*********************************!*\
  !*** ./src/rules/conditions.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const spsLexer = __webpack_require__(/*! ../nut-lex */ \"./src/nut-lex.js\")\r\n// const { Parser } = require(\"chevrotain\")\r\nconst toks = spsLexer.tokens\r\n\r\nmodule.exports = ($) => {\r\n    $.RULE(\"Condition\", () => {\r\n        $.SUBRULE($.Expression)\r\n        $.OPTION(() => {\r\n            $.SUBRULE1($.Operator)\r\n            $.SUBRULE2($.Expression)\r\n        })\r\n    })\r\n    $.RULE(\"subOperator\", () => {\r\n        $.OR([\r\n            { ALT: () => $.CONSUME(toks.Sub) },\r\n            { ALT: () => $.CONSUME(toks.SubOp) }\r\n        ])\r\n        return true\r\n    })\r\n    $.RULE(\"Operator\", () => {\r\n        $.OR([\r\n            { ALT: () => $.CONSUME(toks.Equals) },\r\n            { ALT: () => $.CONSUME(toks.NotEquals) },\r\n            { ALT: () => $.CONSUME(toks.IsOp) },\r\n            { ALT: () => $.CONSUME(toks.GT_Op) },\r\n            { ALT: () => $.CONSUME(toks.LT_Op) },\r\n            { ALT: () => $.CONSUME(toks.GE_Op) },\r\n            { ALT: () => $.CONSUME(toks.AndCond) },\r\n            { ALT: () => $.CONSUME(toks.OrCond) },\r\n            { ALT: () => $.CONSUME(toks.HasRoleCond) },\r\n\r\n        ])\r\n    })\r\n    $.RULE(\"identifierLHSList\", () => {\r\n        let lhs = []\r\n        $.OR([\r\n            { ALT: () => lhs.push($.SUBRULE($.identifierLHS)) },\r\n            {\r\n                ALT: () => {\r\n                    $.CONSUME(toks.LBracket);\r\n                    $.MANY(() => {\r\n                        lhs.push($.SUBRULE1($.identifierLHS)) \r\n                    })\r\n                    $.CONSUME(toks.RBracket);\r\n                }\r\n            }\r\n        ])\r\n        return lhs\r\n    })\r\n    $.RULE(\"identifierLHS\", () => {\r\n        return $.OR([\r\n            { ALT: () => $.CONSUME(toks.StorySec).image },\r\n            { ALT: () => $.CONSUME(toks.SceneId).image },\r\n            { ALT: () => $.CONSUME(toks.InteractionId).image },\r\n            { ALT: () => $.CONSUME(toks.ObjectiveId).image },\r\n            { ALT: () => $.SUBRULE($.roleCastId) },\r\n            { ALT: () => $.CONSUME(toks.Identifier).image }\r\n            //{ ALT: () => $.CONSUME(toks.CastId) }\r\n        ])\r\n    })\r\n\r\n    $.RULE(\"setLHS\", () => {\r\n        let ids = $.SUBRULE($.identifierLHSList)\r\n        let elements = \"\"\r\n        $.OPTION(() => {\r\n            $.MANY(() => {\r\n                elements += $.CONSUME(toks.DataId).image\r\n            })\r\n        })\r\n        return {ids, elements}\r\n    })\r\n    $.RULE(\"identifierExpression\", () => {\r\n        let exp = $.SUBRULE($.identifierLHS)\r\n        let annotation = $.OPTION(()=> $.SUBRULE($.annotationId)) \r\n        annotation = annotation?annotation:'value';\r\n        let sub = ''\r\n        $.OPTION2(() => {\r\n            $.MANY(() => {\r\n               sub += $.CONSUME(toks.DataId).image\r\n            })\r\n        })\r\n        if (sub) {\r\n            exp += annotation + sub\r\n        }\r\n        return exp\r\n    })\r\n    $.RULE(\"Expression\", () => {\r\n        $.OR([\r\n            { ALT: () => $.SUBRULE($.identifierExpression) },\r\n            { ALT: () => $.CONSUME(toks.StringLiteral) },\r\n            { ALT: () => $.CONSUME(toks.IntegerLiteral) },\r\n            { ALT: () => $.CONSUME(toks.NumberLiteral) },\r\n            { ALT: () => $.SUBRULE($.booleanValue) },\r\n            { ALT: () => $.CONSUME(toks.Null) },\r\n            { ALT: () => $.SUBRULE($.parenthesisExpression) },\r\n\r\n        ])\r\n    })\r\n\r\n    $.RULE(\"parenthesisExpression\", () => {\r\n        $.CONSUME(toks.LParen)\r\n        $.SUBRULE($.Condition)\r\n        $.CONSUME(toks.RParen)\r\n    })\r\n}\n\n//# sourceURL=webpack:///./src/rules/conditions.js?");

/***/ }),

/***/ "./src/rules/expressions.js":
/*!**********************************!*\
  !*** ./src/rules/expressions.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const spsLexer = __webpack_require__(/*! ../nut-lex */ \"./src/nut-lex.js\")\r\n// const { Parser } = require(\"chevrotain\")\r\nconst toks = spsLexer.tokens\r\n\r\nmodule.exports = ($) => {\r\n    // role-list\r\n    // : ROLE_ID \r\n    // | LBRACKET ROLE_ID* RBRACKET\r\n    // ;\r\n    $.RULE(\"roleIdList\", () => {\r\n        let roles = []\r\n        $.OR([\r\n            {\r\n                ALT: () => {\r\n                    $.CONSUME(toks.LBracket);\r\n                    $.MANY(() => {\r\n                       roles.push($.CONSUME(toks.RoleId).image)\r\n                    })\r\n                    $.CONSUME(toks.RBracket);\r\n                }\r\n            },\r\n            { ALT: () => roles.push($.CONSUME2(toks.RoleId).image) },\r\n        ])\r\n        return roles;\r\n    })\r\n    // role-list\r\n    // : ROLE_ID \r\n    // | LBRACKET ROLE_ID* RBRACKET\r\n    // ;\r\n    $.RULE(\"roleCastIdList\", () => {\r\n        let list = []\r\n        $.OR([\r\n            {\r\n                ALT: () => {\r\n                    $.CONSUME(toks.LBracket);\r\n                    $.MANY(() => {\r\n                        list.push($.SUBRULE($.roleCastId))\r\n                    })\r\n                    $.CONSUME(toks.RBracket);\r\n                }\r\n            },\r\n            { ALT: () => list.push($.SUBRULE1($.roleCastId)) },\r\n        ])\r\n        return list\r\n    })\r\n    $.RULE(\"roleCastId\", () => {\r\n        let id \r\n        $.OR([\r\n            { ALT: () => id  = $.CONSUME(toks.RoleId).image },\r\n            { ALT: () => id = $.CONSUME(toks.CastId).image }\r\n        ])\r\n        return id\r\n    })\r\n    \r\n    $.RULE(\"ObjectiveIdList\", () => {\r\n        let list = []\r\n        $.OR([\r\n            {\r\n                ALT: () => {\r\n                    $.CONSUME(toks.LBracket);\r\n                    $.MANY(() => {\r\n                        list.push($.CONSUME(toks.ObjectiveId).image)\r\n                    })\r\n                    $.CONSUME(toks.RBracket);\r\n                }\r\n            },\r\n            { ALT: () => list.push($.CONSUME1(toks.ObjectiveId).image) },\r\n        ])\r\n        return list\r\n    })\r\n\r\n\r\n\r\n    $.RULE('mTime', () => {\r\n        let m = $.CONSUME(toks.MinuteLiteral).image\r\n        let s = $.OPTION(()=> $.CONSUME(toks.SecondLiteral).image)\r\n        let ms = $.OPTION1(()=> $.CONSUME(toks.MillisecondLiteral).image)\r\n        // calc time ine milliseconds\r\n        let total = 0\r\n        total += m? parseInt(m)*60000: 0\r\n        total += s? parseInt(s)*1000: 0\r\n        total += ms? parseInt(ms): 0\r\n        return total\r\n\r\n    })\r\n    $.RULE('sTime', () => {\r\n        let s = $.CONSUME(toks.SecondLiteral).image\r\n        let ms = $.OPTION(()=> $.CONSUME(toks.MillisecondLiteral).image)\r\n        let total = 0\r\n        total += s? parseInt(s)*1000: 0\r\n        total += ms? parseInt(ms): 0\r\n        return total\r\n    })\r\n    $.RULE('msTime', () => {\r\n        let ms = $.CONSUME(toks.MillisecondLiteral).image\r\n        return parseInt(ms)\r\n    })\r\n\r\n    // time-unit\r\n    // : minutes seconds milliseconds\r\n    // |  minutes seconds\r\n    // |  seconds milliseconds\r\n    // |  minutes \r\n    // |  seconds\r\n    // |  milliseconds\r\n    // ;\r\n    $.RULE('timeUnits', () => {\r\n        let ms = $.OR([\r\n            { ALT: () => $.SUBRULE($.mTime) },\r\n            { ALT: () => $.SUBRULE($.sTime) },\r\n            { ALT: () => $.SUBRULE($.msTime) }\r\n        ])\r\n        return ms\r\n    })\r\n}\r\n\n\n//# sourceURL=webpack:///./src/rules/expressions.js?");

/***/ }),

/***/ "./src/rules/import.js":
/*!*****************************!*\
  !*** ./src/rules/import.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const spsLexer = __webpack_require__(/*! ../nut-lex */ \"./src/nut-lex.js\")\r\n// const { Parser } = require(\"chevrotain\")\r\nconst toks = spsLexer.tokens\r\n\r\nmodule.exports = ($) => {\r\n    $.RULE('imports', () => {\r\n        $.CONSUME(toks.ImportSec).image\r\n        $.CONSUME(toks.Colon)\r\n        $.CONSUME(toks.Indent)  \r\n        $.pushImport()\r\n        $.MANY(() => {\r\n            let script = $.trimString($.CONSUME(toks.StringLiteral).image)\r\n            $.importScript(script)\r\n        })\r\n        $.popImport()\r\n        $.CONSUME(toks.Outdent)  \r\n    })\r\n}\n\n//# sourceURL=webpack:///./src/rules/import.js?");

/***/ }),

/***/ "./src/rules/interactions.js":
/*!***********************************!*\
  !*** ./src/rules/interactions.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const spsLexer = __webpack_require__(/*! ../nut-lex */ \"./src/nut-lex.js\")\r\nconst submitRules = __webpack_require__(/*! ./submit */ \"./src/rules/submit.js\");\r\n// const { Parser } = require(\"chevrotain\")\r\nconst toks = spsLexer.tokens\r\nconst {SymbolTypes, InteractionTypes} = __webpack_require__(/*! ../nut-types */ \"./src/nut-types.js\")\r\n\r\nmodule.exports = ($) => {\r\n    submitRules($)\r\n    $.RULE('interactions', () => {\r\n        $.CONSUME(toks.InteractionSec);\r\n        $.OR([\r\n            { ALT: () => $.SUBRULE($.interaction) },\r\n            {\r\n                ALT: () => {\r\n                    $.CONSUME(toks.Colon);\r\n                    $.CONSUME(toks.Indent);\r\n                    $.MANY(() => {\r\n                        $.SUBRULE1($.interaction)\r\n                    })\r\n                    $.CONSUME(toks.Outdent);\r\n                }\r\n            }\r\n        ])\r\n    })\r\n\r\n    // interaction-command \r\n    //     : INTERACTION_STATEMENT INTERACTION_ID? role-cast-list? string?  FORM\r\n    //     | INTERACTION_STATEMENT INTERACTION_ID? role-cast-list? string?  SEARCH\r\n    //     ;\r\n    $.RULE('interaction', () => {\r\n        let id = $.CONSUME(toks.InteractionId).image;\r\n        let audience  = $.SUBRULE($.roleCastIdList)\r\n        let desc = $.trimString($.CONSUME(toks.StringLiteral).image);\r\n        //$.pushInteraction({id, audience, desc})\r\n        \r\n        let shot = { type: SymbolTypes.Interaction, id, audience, desc}\r\n        $.pushShot(shot)\r\n        shot.content = $.SUBRULE($.interactionBlockItem)\r\n        $.pushShot(id)\r\n        // $.popInteraction(id)\r\n        // probably need a sub\r\n        return shot\r\n        \r\n    })\r\n\r\n    $.RULE('interactionBlockItem', () => {\r\n        return $.OR([\r\n            { ALT: () => $.SUBRULE($.form) },\r\n            { ALT: () => $.SUBRULE($.choiceInteraction) },\r\n            { ALT: () => $.SUBRULE($.searchCmd) },\r\n            { ALT: () => $.SUBRULE($.completeObjCmd) },\r\n            { ALT: () => $.SUBRULE($.KeysInteraction) },\r\n            { ALT: () => $.SUBRULE($.MediaInteraction) },\r\n        ])\r\n    })\r\n\r\n    $.RULE('choiceInteraction', () => {\r\n        $.CONSUME(toks.ChoiceBlock);\r\n        $.CONSUME(toks.Colon)\r\n        $.CONSUME(toks.Indent)\r\n        let content = {type: InteractionTypes.Choice , choices: []}\r\n        \r\n        $.AT_LEAST_ONE(()=> {\r\n            let choice = {}\r\n            choice.target = $.OPTION(()=> $.SUBRULE($.roleCastIdList))\r\n            choice.prompt = $.trimString($.CONSUME(toks.StringLiteral).image)\r\n            choice.content = $.SUBRULE($.IfElseCmdBlock)\r\n            content.choices.push(choice);\r\n         })\r\n         $.CONSUME(toks.Outdent) \r\n         return content\r\n    })\r\n\r\n    $.RULE('KeysInteraction', () => {\r\n        $.CONSUME(toks.KeysBlock);\r\n        $.CONSUME(toks.Colon)\r\n        $.CONSUME(toks.Indent)                  \r\n        $.MANY(()=> {\r\n            $.CONSUME(toks.StringLiteral)\r\n            $.SUBRULE($.IfElseCmdBlock)\r\n         })\r\n         $.CONSUME(toks.Outdent)       \r\n    })\r\n\r\n    $.RULE('MediaInteraction', () => {\r\n        $.CONSUME(toks.MediaSec);\r\n        $.CONSUME(toks.MediaId);\r\n        $.CONSUME(toks.Colon)\r\n        $.CONSUME(toks.Indent)                  \r\n        $.MANY(()=> {\r\n            $.SUBRULE($.ClickData)\r\n            $.SUBRULE($.IfElseCmdBlock)\r\n         })\r\n         $.CONSUME(toks.Outdent)       \r\n    })\r\n    $.RULE('ClickData', () => {\r\n        $.CONSUME(toks.ClickCmd);\r\n        $.CONSUME1(toks.IntegerLiteral);\r\n        $.CONSUME2(toks.Comma);\r\n        $.CONSUME3(toks.IntegerLiteral);\r\n        $.CONSUME4(toks.Comma);\r\n        $.CONSUME5(toks.IntegerLiteral);\r\n        $.CONSUME6(toks.Comma);\r\n        $.CONSUME7(toks.IntegerLiteral);\r\n        \r\n    })\r\n\r\n    $.RULE('completeObjCmd', () => {\r\n        $.CONSUME(toks.CompleteCmd);\r\n        $.SUBRULE($.ObjectiveIdList)\r\n        $.SUBRULE($.IfElseCmdBlock)\r\n    })\r\n\r\n\r\n    $.RULE('form', () => {\r\n        $.CONSUME(toks.FormBlock);\r\n        $.SUBRULE($.formElementBlock)\r\n        //$.SUBRULE($.submitFormElement)\r\n    })\r\n    $.RULE('formElementBlock', () => {\r\n        $.OR([\r\n            { ALT: () => $.SUBRULE($.formElement) },\r\n            {\r\n                ALT: () => {\r\n                    $.CONSUME(toks.Colon)\r\n                    $.CONSUME(toks.Indent)\r\n                    $.MANY(()=>$.SUBRULE1($.formElement))\r\n                    $.CONSUME(toks.Outdent)\r\n                }\r\n            }\r\n        ])\r\n    })\r\n\r\n  \r\n\r\n\r\n    $.RULE('formElement', () => {\r\n        $.OR([\r\n            { ALT: () => $.SUBRULE($.inputFormElement) },\r\n            { ALT: () => $.SUBRULE($.labelFormElement) },\r\n            { ALT: () => $.SUBRULE($.selectFormElement) },\r\n            { ALT: () => $.SUBRULE($.submitFormElement) }\r\n        ])\r\n    })\r\n    $.RULE('inputFormElement', () => {\r\n        $.CONSUME(toks.InputElement)\r\n        $.CONSUME(toks.Identifier)\r\n    })\r\n    $.RULE('labelFormElement', () => {\r\n        $.CONSUME(toks.LabelElement)\r\n        $.CONSUME(toks.StringLiteral);\r\n    }) \r\n    $.RULE('selectFormElement', () => {\r\n        $.CONSUME(toks.SelectElement)\r\n        $.CONSUME(toks.Identifier)\r\n        $.SUBRULE($.selectChoiceList)\r\n    })\r\n\r\n    $.RULE('selectChoiceList', () => {\r\n            $.CONSUME(toks.Colon);\r\n            $.CONSUME(toks.Indent)\r\n            $.MANY(()=> $.SUBRULE1($.selectChoice))\r\n            $.CONSUME(toks.Outdent)\r\n    })\r\n\r\n    $.RULE(\"selectChoice\", ()=> {\r\n        $.OR([\r\n            {ALT: ()=> $.CONSUME(toks.RoleId)},\r\n            {ALT: ()=> $.CONSUME(toks.CastId)},\r\n            {ALT: ()=> $.CONSUME(toks.StringLiteral)}\r\n        ])\r\n    })\r\n\r\n    \r\n    // NOTE: Change this from original the interaction has the who is search\r\n    /// the search block has the FOR who\r\n    // search-command\r\n    // : SEARCH_STATEMENT role-cast-list\r\n    // ;\r\n    $.RULE('searchCmd', () => {\r\n        $.CONSUME(toks.SearchCmd)\r\n        $.SUBRULE($.roleCastIdList)\r\n       // $.SUBRULE($.seachConditionals)\r\n    })\r\n\r\n    // $.RULE(\"whenBlock\", ()=> {\r\n    //     $.CONSUME(toks.WhenSec)\r\n    //     // $.SUBRULE($.whenCond)\r\n    //     $.SUBRULE($.whenCmdBlock)\r\n    // })\r\n    \r\n}\n\n//# sourceURL=webpack:///./src/rules/interactions.js?");

/***/ }),

/***/ "./src/rules/media.js":
/*!****************************!*\
  !*** ./src/rules/media.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const spsLexer = __webpack_require__(/*! ../nut-lex */ \"./src/nut-lex.js\")\r\n// const { Parser } = require(\"chevrotain\")\r\nconst toks = spsLexer.tokens\r\n\r\nmodule.exports = ($) => {\r\n    //     media-definition\r\n    //     : MEDIA_ID  alias-string\r\n    //     ;\r\n    $.RULE('mediaDef', () => {\r\n        let id = $.CONSUME(toks.MediaId).image;\r\n        let uri = $.SUBRULE($.aliasString).image;\r\n        $.addMedia({id, uri})\r\n    })\r\n    // media-definition-block\r\n    //     : MEDIA_STATEMENT COLON INDENT media-definition* DEDENT\r\n    //     ;\r\n    $.RULE('media', () => {\r\n        $.CONSUME(toks.MediaSec);\r\n        $.CONSUME(toks.Colon)\r\n        $.CONSUME(toks.Indent)\r\n        $.MANY(() => {\r\n            $.SUBRULE($.mediaDef)\r\n        })\r\n        $.CONSUME(toks.Outdent)\r\n    })\r\n}\n\n//# sourceURL=webpack:///./src/rules/media.js?");

/***/ }),

/***/ "./src/rules/objectives.js":
/*!*********************************!*\
  !*** ./src/rules/objectives.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const spsLexer = __webpack_require__(/*! ../nut-lex */ \"./src/nut-lex.js\")\r\n// const { Parser } = require(\"chevrotain\")\r\nconst toks = spsLexer.tokens\r\n\r\nmodule.exports = ($) => {\r\n    $.RULE('objectives', () => {\r\n        $.CONSUME(toks.ObjectiveSec);\r\n        $.CONSUME(toks.Colon);\r\n        $.CONSUME(toks.Indent);\r\n        $.MANY(() => {\r\n            $.SUBRULE1($.objective)\r\n        })\r\n        $.CONSUME(toks.Outdent);\r\n    })\r\n    // objective-command \r\n    // : OBJECTIVE_ID role-cast-list string show-state? COLON (objective-when-block)?\r\n    // ;\r\n    $.RULE('objective', () => {\r\n        let id\r\n        let target\r\n        let desc\r\n        $.OR([\r\n            { ALT: () => id = $.CONSUME(toks.ObjectiveId).image },\r\n            { ALT: () => id = '*' + $.CONSUME(toks.Identifier).image }\r\n        ])\r\n        target = $.SUBRULE($.roleCastIdList);\r\n        desc = $.CONSUME(toks.StringLiteral).image;\r\n        $.addObjective({ id, target, desc })\r\n    })\r\n\r\n}\n\n//# sourceURL=webpack:///./src/rules/objectives.js?");

/***/ }),

/***/ "./src/rules/role.js":
/*!***************************!*\
  !*** ./src/rules/role.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const spsLexer = __webpack_require__(/*! ../nut-lex */ \"./src/nut-lex.js\")\r\n// const { Parser } = require(\"chevrotain\")\r\nconst toks = spsLexer.tokens\r\n\r\nmodule.exports = ($) => {\r\n    // alias-string\r\n    // : LPREN string RPREN\r\n    // ;\r\n    $.RULE('aliasString', () => {\r\n        $.CONSUME(toks.LParen);\r\n        let alias = $.trimString($.CONSUME(toks.StringLiteral).image)\r\n        $.CONSUME(toks.RParen);\r\n        return alias\r\n    })\r\n    //  role-definition-block\r\n    // : ROLES_STATEMENT COLON INDENT role-definition* DEDENT\r\n    // ;\r\n    $.RULE('roles', () => {\r\n        $.CONSUME(toks.RoleSec);\r\n        $.CONSUME(toks.Colon)\r\n        $.CONSUME(toks.Indent)\r\n        $.MANY(() => {\r\n            let annotations= $.SUBRULE($.annotationList)\r\n            let meta = $.SUBRULE($.roleDef)\r\n            annotations.meta = meta\r\n            annotations.id = meta.id;\r\n            $.addRole(annotations)\r\n        })\r\n        $.CONSUME(toks.Outdent)\r\n    })\r\n    // role-definition\r\n    // : ROLE_ID (alias-string)? string?\r\n    // | ID (alias-string)? string?\r\n    // ;\r\n    $.RULE(\"roleDef\", () => {\r\n        let id = $.OR([\r\n            {ALT: ()=> $.CONSUME(toks.RoleId).image},\r\n            {ALT: ()=> '#'+ $.CONSUME(toks.Identifier).image}\r\n        ]);\r\n        let alias = $.OPTION(() =>  $.SUBRULE($.aliasString))\r\n        let desc = $.OPTION2(() =>  $.CONSUME(toks.StringLiteral).image)\r\n        return {id,alias,desc}\r\n\r\n    })\r\n}\n\n//# sourceURL=webpack:///./src/rules/role.js?");

/***/ }),

/***/ "./src/rules/scene.js":
/*!****************************!*\
  !*** ./src/rules/scene.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const spsLexer = __webpack_require__(/*! ../nut-lex */ \"./src/nut-lex.js\")\r\n// const { Parser } = require(\"chevrotain\")\r\nconst toks = spsLexer.tokens\r\n\r\nmodule.exports = ($) => {\r\n    // story-definition\r\n    // : STORY_STATEMENT (alias-string)? string? COLON INDENT \r\n    //  scene-content\r\n    // DEDENT\r\n    // ;\r\n    $.RULE('story', () => {\r\n        $.OPTION(()=> $.SUBRULE($.annotationList))\r\n\r\n        $.CONSUME(toks.StorySec);\r\n        let alias = $.OPTION1(() => $.SUBRULE($.aliasString))\r\n        let desc = $.OPTION2(() => $.CONSUME(toks.StringLiteral).image)\r\n        let value = $.OPTION3(() =>  $.SUBRULE($.objectValue))\r\n        let id = 'story'\r\n        let scene = { id, alias, desc, value}\r\n        $.pushStory(scene)\r\n        let content = $.SUBRULE($.sceneContent);\r\n        scene.content = content\r\n        $.popStory(scene)\r\n        return scene\r\n    })\r\n    // scene-definition \r\n    // :  SCENE_ID \r\n    // ;\r\n\r\n    $.RULE('scene', () => {\r\n        let sub = $.OPTION(() => $.SUBRULE($.subOperator)?true:false) \r\n        let id = $.OPTION1(() => $.CONSUME(toks.SceneId).image) \r\n        id = id ? id : $.anonymousID('$') \r\n        let alias = $.OPTION2(() => $.SUBRULE($.aliasString))\r\n        let desc = $.OPTION3(() => $.CONSUME(toks.StringLiteral).image)\r\n        let value = $.OPTION4(() =>  $.SUBRULE($.objectValue))\r\n\r\n        let scene = { id, alias, desc, value, sub}\r\n        $.pushScene(scene)\r\n        let content = $.SUBRULE($.sceneContent);\r\n        scene.content = content\r\n        $.popScene(scene)\r\n        return scene\r\n    })\r\n\r\n    $.RULE('sceneContentStartStates', () => {\r\n        let content = {}\r\n        $.OPTION1(() => {\r\n            $.OPTION2(()=> $.SUBRULE1($.annotationList))\r\n            content.startup = $.SUBRULE($.startup)\r\n        })\r\n        $.OPTION3(() => {\r\n            $.OPTION4(()=> $.SUBRULE2($.annotationList))\r\n            content.enter = $.SUBRULE($.enter)\r\n        })\r\n        return content;\r\n    })\r\n\r\n    $.RULE('sceneContentObjInt', () => {\r\n        let content = {}\r\n        $.OPTION(() => {\r\n            $.SUBRULE($.objectives)\r\n        })\r\n        $.OPTION1(() => {\r\n            $.SUBRULE($.interactions)\r\n        })\r\n    })\r\n    // Common for story and Scene \r\n    // Story is the main scene\r\n    //  ... (alias-string)? string? COLON INDENT \r\n    //   scene-content\r\n    // DEDENT\r\n    //   objective-section?\\[objs]\r\n    //   interaction-section?\\[ints] \r\n    //   startup-section?\\[start] \r\n    //   enter-section?\\[enter] \r\n    //   leave-section?\\[leave] \r\n    $.RULE('sceneContent', () => {\r\n        let content = {}\r\n\r\n\r\n        $.CONSUME(toks.Colon);\r\n        $.CONSUME(toks.Indent);\r\n        \r\n        $.SUBRULE($.sceneContentObjInt)\r\n        Object.assign(content, $.SUBRULE($.sceneContentStartStates))\r\n        \r\n        $.OPTION6(() => {\r\n            let shots = []\r\n            $.MANY(() => {\r\n                $.OPTION(()=> $.SUBRULE3($.annotationList))\r\n                let shot = $.OR([\r\n                    {ALT: ()=> $.SUBRULE($.interaction)},\r\n                    {ALT: ()=> $.SUBRULE($.shot)}\r\n                ])\r\n                shots.push(shot)\r\n            })\r\n            if (shots.length) {\r\n                content.shots = shots\r\n            }\r\n        })\r\n        $.OPTION7(() => {\r\n            $.OPTION8(()=> $.SUBRULE4($.annotationList))\r\n            content.leave = $.SUBRULE($.leave)\r\n        })\r\n\r\n        $.CONSUME(toks.Outdent);\r\n        return content;\r\n    })\r\n\r\n\r\n\r\n    // scene-definition-block\r\n    // : SCENES_STATEMENT COLON INDENT \r\n    //      scene-definition* \r\n    //  DEDENT\r\n    // ;\r\n    $.RULE('scenes', () => {\r\n        $.CONSUME(toks.SceneSec);\r\n        $.CONSUME(toks.Colon);\r\n        $.CONSUME(toks.Indent);\r\n        $.MANY(() => {\r\n            $.OPTION(()=> $.SUBRULE($.annotationList))\r\n            $.SUBRULE($.scene);\r\n        })\r\n        $.CONSUME(toks.Outdent);\r\n    })\r\n}\n\n//# sourceURL=webpack:///./src/rules/scene.js?");

/***/ }),

/***/ "./src/rules/script.js":
/*!*****************************!*\
  !*** ./src/rules/script.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const spsLexer = __webpack_require__(/*! ../nut-lex */ \"./src/nut-lex.js\")\r\n// const { Parser } = require(\"chevrotain\")\r\nconst toks = spsLexer.tokens\r\n\r\nmodule.exports = ($) => {\r\n    // script\r\n    // : (script-data)? \r\n    //   (media-definition-block)? \r\n    //   (role-definition-block)? \r\n    //   (cast-definition-block)?  \r\n    //   (story-definition)? \r\n    //   (scene-definition-block)? EOF_STATEMENT\r\n    $.RULE('script', () => {\r\n        let script = $.OPTION(() => $.SUBRULE($.scriptData))\r\n        $.pushScript(script)\r\n        $.OPTION1(() => $.SUBRULE($.imports))\r\n        $.OPTION2(() => $.SUBRULE($.media))\r\n        $.OPTION3(() => $.SUBRULE($.roles))\r\n        $.OPTION4(() => $.SUBRULE($.cast))\r\n        $.OPTION5(() => $.SUBRULE($.story))\r\n        $.OPTION6(() => $.SUBRULE($.scenes))\r\n        $.popScript()\r\n    })\r\n    // script-data\r\n    // : SCRIPT_STATEMENT alias-string string\r\n    // ;\r\n    $.RULE('scriptData', () => {\r\n        let id = $.CONSUME(toks.ScriptSec).image\r\n        let alias = $.OPTION(() => $.SUBRULE($.aliasString))\r\n        let desc = $.OPTION1(() => $.CONSUME(toks.StringLiteral).image)\r\n        let main = $.OPTION2(() => $.CONSUME(toks.SceneId).image)\r\n        $.addScript({id, alias, desc, main})\r\n    })\r\n}\n\n//# sourceURL=webpack:///./src/rules/script.js?");

/***/ }),

/***/ "./src/rules/states.js":
/*!*****************************!*\
  !*** ./src/rules/states.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const spsLexer = __webpack_require__(/*! ../nut-lex */ \"./src/nut-lex.js\")\r\n// const { Parser } = require(\"chevrotain\")\r\nconst toks = spsLexer.tokens\r\nconst {SymbolTypes} = __webpack_require__(/*! ../nut-types */ \"./src/nut-types.js\")\r\n\r\nmodule.exports = ($) => {\r\n    // startup-section-block\r\n    //     : STARTUP_STATEMENT COLON INDENT startup-section-item* DEDENT\r\n    //     ;\r\n    $.RULE('startup', () => {\r\n        $.CONSUME(toks.StartupBlock)\r\n        return $.SUBRULE($.stateCmdBlock)\r\n    })\r\n    // enter-section-block\r\n    //     :  ENTER_STATEMENT COLON INDENT state-section-item* DEDENT\r\n    //     ;\r\n    $.RULE('enter', () => {\r\n        $.CONSUME(toks.EnterBlock)\r\n        return $.SUBRULE($.stateCmdBlock)\r\n    })\r\n    // leave-section-block\r\n    //     :  LEAVE_STATEMENT COLON INDENT state-section-item* DEDENT\r\n    //     ;\r\n    $.RULE('leave', () => {\r\n        $.CONSUME(toks.LeaveBlock)\r\n        return $.SUBRULE($.stateCmdBlock)\r\n    })\r\n\r\n    $.RULE('shot', () => {\r\n        let sub = $.OPTION(() => $.SUBRULE($.subOperator)) \r\n        let id = $.OPTION1(()=> $.CONSUME(toks.Identifier).image)\r\n        let alias = $.OPTION2(()=> $.SUBRULE($.aliasString).image)\r\n        id = id ? id: $.anonymousID('shot') \r\n\r\n        let shot = { type: SymbolTypes.Shot, id, alias, sub}\r\n        $.pushShot(shot)\r\n        let content = $.SUBRULE($.stateCmdBlock);\r\n        shot.content = content\r\n        $.popShot(shot)\r\n        return shot\r\n\r\n    })\r\n\r\n    $.RULE('stateCmdBlock', () => {\r\n        let cmds = []\r\n        $.CONSUME(toks.Colon)\r\n        $.CONSUME(toks.Indent)\r\n        $.MANY(() => {\r\n            let annotations= $.SUBRULE($.annotationList)\r\n            let cmd = $.SUBRULE($.stateCommand)\r\n            \r\n            if (cmd) {\r\n                cmd.annotations = annotations\r\n                cmds.push(cmd)\r\n            }\r\n        })\r\n        $.CONSUME(toks.Outdent)\r\n        return cmds;\r\n    })\r\n\r\n    // startup-section-item\r\n    //     : tell-command\r\n    //     | scene-command\r\n    //     | set-command\r\n    //     | delay-command\r\n    //     ;\r\n    $.RULE('stateCommand', () => {\r\n       return  $.OR([\r\n            { ALT: () => $.SUBRULE($.asCmd) },\r\n            { ALT: () => $.SUBRULE($.doCmd) },\r\n            { ALT: () => $.SUBRULE($.cueCmd) },\r\n            { ALT: () => $.SUBRULE($.tellCmd) },\r\n            { ALT: () => $.SUBRULE($.setCmd) },\r\n            { ALT: () => $.SUBRULE($.delayCmd) },\r\n            { ALT: () => $.SUBRULE($.sceneCmd) },\r\n            { ALT: () => $.SUBRULE($.forCmd) },\r\n        ])\r\n    })\r\n\r\n\r\n}\n\n//# sourceURL=webpack:///./src/rules/states.js?");

/***/ }),

/***/ "./src/rules/submit.js":
/*!*****************************!*\
  !*** ./src/rules/submit.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const spsLexer = __webpack_require__(/*! ../nut-lex */ \"./src/nut-lex.js\")\r\n// const { Parser } = require(\"chevrotain\")\r\nconst toks = spsLexer.tokens\r\n\r\n/*\r\n    SUBMIT \"OK\"\r\n    if form.weapon == \"Pistol\":\r\n        tell\r\n    else if form.sender == @dawn \r\n    else if form.user has role #human\r\n*/\r\n\r\nmodule.exports = ($) => {\r\n    $.RULE('submitFormElement', () => {\r\n        $.CONSUME(toks.SubmitElement)\r\n        $.OPTION(() => $.CONSUME(toks.StringLiteral))\r\n        $.OPTION1(() => $.SUBRULE($.submitIfElseBlock))\r\n    })\r\n    $.RULE(\"submitIfElseBlock\", () => {\r\n        // $.SUBRULE($.submitConditions)\r\n        $.CONSUME(toks.Colon);\r\n        $.CONSUME(toks.Indent)\r\n        $.OPTION(() => {\r\n            $.SUBRULE($.IfCmd)\r\n            $.OPTION1(() => $.MANY(() => $.SUBRULE1($.ElseCmd)))\r\n        })\r\n        $.OPTION2(() => $.SUBRULE2($.AlwaysCmd))\r\n        $.CONSUME(toks.Outdent)\r\n    })\r\n    $.RULE(\"IfCmd\", () => {\r\n        $.CONSUME(toks.If)\r\n        $.SUBRULE($.Condition)\r\n        $.SUBRULE1($.IfElseCmdBlock)\r\n    })\r\n    $.RULE(\"ElseCmd\", () => {\r\n        $.CONSUME(toks.Else)\r\n        $.OR([\r\n            { ALT: () => $.SUBRULE($.IfCmd) },\r\n            { ALT: () => $.SUBRULE($.IfElseCmdBlock) }\r\n        ])\r\n\r\n    })\r\n    $.RULE(\"AlwaysCmd\", () => {\r\n        $.CONSUME(toks.Always)\r\n        $.SUBRULE($.IfElseCmdBlock)\r\n    })\r\n    $.RULE(\"IfElseCmdBlock\", () => {\r\n        let cmds = []\r\n        $.CONSUME(toks.Colon);\r\n        $.CONSUME(toks.Indent)\r\n        $.OR([\r\n            { ALT: () => $.CONSUME(toks.PassCmd) },\r\n            {\r\n                ALT: () => $.MANY(() => {\r\n                    let annotations= $.SUBRULE($.annotationList)\r\n                    let cmd = $.SUBRULE($.ifElseValidCmd)          \r\n                    if (cmd) {\r\n                        cmd.annotations = annotations\r\n                        cmds.push(cmd)\r\n                    }\r\n                })\r\n            }\r\n        ])\r\n        $.CONSUME(toks.Outdent)\r\n        return cmds\r\n    })\r\n\r\n    $.RULE(\"ifElseValidCmd\", () => {\r\n        return $.OR([\r\n            { ALT: () => $.SUBRULE($.asCmd) },\r\n            { ALT: () => $.SUBRULE($.doCmd) },\r\n            { ALT: () => $.SUBRULE($.tellCmd) },\r\n            { ALT: () => $.SUBRULE($.cueCmd) },\r\n            { ALT: () => $.SUBRULE($.sceneCmd) },\r\n            { ALT: () => $.SUBRULE($.setCmd) },\r\n            { ALT: () => $.SUBRULE($.delayCmd) },\r\n            { ALT: () => $.SUBRULE($.completeCmd) },\r\n            { ALT: () => $.SUBRULE($.showCmd) },\r\n            { ALT: () => $.SUBRULE($.hideCmd) },\r\n            { ALT: () => $.SUBRULE($.failCmd) },\r\n            // {ALT: ()=> $.SUBRULE($.askCmd)}\r\n        ])\r\n    })\r\n}\r\n\n\n//# sourceURL=webpack:///./src/rules/submit.js?");

/***/ }),

/***/ "./src/rules/value.js":
/*!****************************!*\
  !*** ./src/rules/value.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const spsLexer = __webpack_require__(/*! ../nut-lex */ \"./src/nut-lex.js\")\r\n// const { Parser } = require(\"chevrotain\")\r\nconst toks = spsLexer.tokens\r\n\r\nmodule.exports = ($) => {\r\n    $.RULE(\"objectValue\", () => {\r\n        let value\r\n        value = $.OR([\r\n            // using ES6 Arrow functions to reduce verbosity.\r\n            { ALT: () => $.SUBRULE($.object) },\r\n            { ALT: () => $.SUBRULE($.array) }\r\n        ])\r\n        return value\r\n    })\r\n\r\n    // the parsing methods\r\n    $.RULE(\"object\", () => {\r\n        let obj = {}\r\n        $.CONSUME(toks.LBrace)\r\n        $.OPTION(()=>$.CONSUME(toks.Indent))\r\n        $.MANY_SEP({\r\n            SEP: toks.Comma,\r\n            DEF: () => {\r\n                let {key, value} = $.SUBRULE2($.objectItem)\r\n                obj[key] = value\r\n            }\r\n        })\r\n        $.OPTION1(()=>$.CONSUME(toks.Outdent))\r\n        $.CONSUME(toks.RBrace)\r\n        return obj\r\n    })\r\n\r\n    $.RULE(\"objectItem\", () => {\r\n        let key\r\n        $.OR([\r\n            {ALT: ()=> key = $.trimString($.CONSUME(toks.StringLiteral).image)},\r\n            {ALT: ()=> key = $.CONSUME(toks.Identifier).image}\r\n        ])\r\n        \r\n        $.CONSUME(toks.Colon)\r\n        let value = $.SUBRULE($.value)\r\n        return {key, value}\r\n    })\r\n\r\n    $.RULE(\"array\", () => {\r\n        let arr = []\r\n        $.CONSUME(toks.LBracket)\r\n        $.MANY_SEP({\r\n            SEP: toks.Comma,\r\n            DEF: () => {\r\n                arr.push($.SUBRULE2($.value))\r\n            }\r\n        })\r\n        $.CONSUME(toks.RBracket)\r\n        return arr\r\n    })\r\n\r\n    $.RULE(\"value\", () => {\r\n        let value \r\n        value = $.OR([\r\n            { ALT: () => $.trimString($.CONSUME(toks.StringLiteral).image) },\r\n            { ALT: () => Number($.CONSUME(toks.IntegerLiteral).image) },\r\n            { ALT: () => Number($.CONSUME(toks.NumberLiteral).image) },\r\n            { ALT: () => $.SUBRULE($.object) },\r\n            { ALT: () =>  $.SUBRULE($.array) },\r\n            { ALT: () => $.SUBRULE($.booleanValue) },\r\n            { ALT: () => $.CONSUME(toks.Null).image? null:undefined }\r\n        ])\r\n        return value\r\n    })\r\n    $.RULE(\"booleanValue\", () => {\r\n        \r\n        return $.OR([\r\n            { ALT: () => $.CONSUME(toks.True).image? true: false  },\r\n            { ALT: () => $.CONSUME(toks.False).image? false:true },\r\n        ])\r\n    })\r\n}\n\n//# sourceURL=webpack:///./src/rules/value.js?");

/***/ })

};;